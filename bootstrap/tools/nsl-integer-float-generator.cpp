#include <yuni/yuni.h>
#include <yuni/core/string.h>
#include <yuni/io/file.h>
#include <yuni/core/hash/checksum/md5.h>
#include <yuni/core/system/environment.h>
#include <iostream>
#include <limits>

using namespace Yuni;

namespace {

bool detectCI() {
	return yuni::System::Environment::ReadAsBool("CI")
		or yuni::System::Environment::ReadAsInt64("CI_JOB_ID");
}

void writeFile(const AnyString& filename, const AnyString& content) {
	yuni::Hash::Checksum::MD5 md5;
	auto oldMD5 = md5.fromFile(filename);
	auto newMD5 = md5.fromRawData(content.c_str(), content.sizeInBytes());
	if (oldMD5 != newMD5) {
		auto lines = content.countChar('\n') + 1;
		std::cout << "updating " << filename << ": ";
		std::cout << "writing " << content.sizeInBytes() << " bytes, " << lines << " lines\n";
		if (detectCI())
			throw "\n  NSL: source modifications not allowed from CI! Please commit the changes.\n";
		IO::File::SetContent(filename, content);
	}
	else
		std::cout << filename << " is already up to date\n";
}

void addFuncAs(Clob& o) {
	o << "\tfunc as<:T:>\n";
	o << "\t\t-> new T(!!as(#[__nanyc_synthetic] typeof(std.asBuiltin(new T)), pod));\n\n";
}

void craftClassFloat(Clob& o, uint32_t bits, const AnyString& license, const AnyString& filename) {
	o.clear();
	ShortString16 suffix;
	char c = 'f';
	suffix << c << bits;
	o << license;
	o << "/// \\file    " << suffix << ".ny\n";
	o << "/// \\brief   Implementation of the class " << suffix << ", ";
	AnyString name;
	switch (bits) {
		case 128: name = "quadruple-precision floating-point number (128bits)"; break;
		case 64:  name = "double-precision floating-point number (64bits)"; break;
		case 32:  name = "single-precision floating-point number (32bits)"; break;
	}
	o << name << '\n';
	o << "/// \\ingroup std.core\n";
	o << '\n';
	o << "/// \\important THIS FILE IS AUTOMATICALLY GENERATED\n";
	o << '\n';
	o << '\n';
	o << "/// \\brief   " << name << '\n';
	o << "/// \\ingroup std.core\n";
	o << "public class " << suffix << " {\n";
	o << "\toperator new;\n\n";
	o << "\toperator new(cref x: f32) {\n";
	o << "\t\tpod = x.pod;\n";
	o << "\t}\n\n";
	if (bits > 32) {
		o << "\toperator new(cref x: f64) {\n";
		o << "\t\tpod = x.pod;\n";
		o << "\t}\n\n";
	}
	o << "\t#[nosuggest] operator new(self pod: __f32);\n\n";
	if (bits > 32)
		o << "\t#[nosuggest] operator new(self pod: __f64);\n\n";
	addFuncAs(o);
	o << "\toperator ++self: ref " << suffix << " {\n";
	o << "\t\tpod = !!finc(pod);\n";
	o << "\t\treturn self;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator self++: ref " << suffix << " {\n";
	o << "\t\tref tmp = new " << suffix << "(pod);\n";
	o << "\t\tpod = !!finc(pod);\n";
	o << "\t\treturn tmp;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator --self: ref " << suffix << " {\n";
	o << "\t\tpod = !!fdec(pod);\n";
	o << "\t\treturn self;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator self--: ref " << suffix << " {\n";
	o << "\t\tref tmp = new " << suffix << "(pod);\n";
	o << "\t\tpod = !!fdec(pod);\n";
	o << "\t\treturn tmp;\n";
	o << "\t}\n";
	o << '\n';
	auto craftOperator = [&](auto callback) {
		callback(bits, c);
	};
	auto craftMemberOperator = [&](const AnyString& op, const AnyString& intrinsic) {
		craftOperator([&](uint32_t b, char targetsign) {
			o << "\toperator " << op << " (cref x: " << targetsign << b << "): ref " << suffix << " {\n";
			o << "\t\tpod = !!" << intrinsic << "(pod, x.pod);\n";
			o << "\t\treturn self;\n";
			o << "\t}\n\n";

			o << "\t#[nosuggest] operator " << op << " (x: __" << targetsign << b << "): ref " << suffix << " {\n";
			o << "\t\tpod = !!" << intrinsic << "(pod, x);\n";
			o << "\t\treturn self;\n";
			o << "\t}\n\n";
		});
	};
	craftMemberOperator("+=", "fadd");
	craftMemberOperator("-=", "fsub");
	craftMemberOperator("*=", "fmul");
	craftMemberOperator("/=", "fdiv");
	o.trimRight();
	o << "\n\n";
	o << "private:\n";
	o << "\tvar pod = 0__" << suffix << ";\n";
	o << '\n';
	o << "} // class " << suffix << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	auto craft = [&](const AnyString& op, const AnyString& builtin, auto callback) {
		char sign = 'f';
		auto b = bits;
		callback(op, builtin, sign, b, "cref ", "cref ");
		callback(op, builtin, sign, b, "cref ", "__");
		callback(op, builtin, sign, b, "__", "cref ");
		callback(op, builtin, sign, b, "__", "__");
		o << '\n';
	};
	auto genGlobalCompareOperator = [&](AnyString op, AnyString builtin, char sign, uint32_t b, AnyString prefixA, AnyString prefixB) {
		o << "#[__nanyc_builtinalias: " << builtin;
		if (prefixA.first() == '_' or prefixB.first() == '_')
			o << ", nosuggest";
		o << "] public operator ";
		o << op << " (a: " << prefixA << suffix << ", b: " << prefixB << sign << b << "): ";
		o << ((prefixA.first() == '_' and prefixB.first() == '_') ? "__" : "ref ");
		o << "bool;\n";
	};
	craft(">",  "fgt",  genGlobalCompareOperator);
	craft(">=", "fgte", genGlobalCompareOperator);
	craft("<",  "flt",  genGlobalCompareOperator);
	craft("<=", "flte", genGlobalCompareOperator);
	craft("==",  "eq",  genGlobalCompareOperator);
	craft("!=",  "neq", genGlobalCompareOperator);
	o << '\n';
	o << '\n';
	auto genGlobalOperator = [&](AnyString op, AnyString builtin, char sign, uint32_t b, AnyString prefixA, AnyString prefixB) {
		bool atLeastOneBuiltin = (prefixA.first() != '_' or prefixB.first() != '_');
		o << "#[__nanyc_builtinalias: " << builtin;
		if (prefixA.first() == '_' or prefixB.first() == '_')
			o << ", nosuggest";
		o << "] public operator ";
		o << op << " (a: " << prefixA << suffix << ", b: " << prefixB << sign << b << "): ";
		o << ((atLeastOneBuiltin) ? "ref " : "__");
		o << suffix << ";\n";
		if (not atLeastOneBuiltin)
			o << '\n';
	};
	craft("+", "fadd", genGlobalOperator);
	craft("-", "fsub", genGlobalOperator);
	craft("/", "fdiv", genGlobalOperator);
	craft("*", "fmul", genGlobalOperator);
	o.trimRight();
	writeFile(filename, o);
}

void craftClassInt(Clob& o, uint32_t bits, bool issigned, const AnyString& license, const AnyString& filename) {
	o.clear();
	char c = (issigned) ? 'i' : 'u';
	ShortString16 suffix;
	suffix << c << bits;
	auto craftOperator = [&](auto callback) {
		callback(bits, c);
		if (issigned)
			callback(bits / 2, 'u');
	};
	auto craft = [&](const AnyString& op, const AnyString& builtin, auto callback) {
		char sign = issigned ? 'i' : 'u';
		for (uint32_t b = 64 /*bits*/; b >= 8; b /= 2) {
			callback(op, builtin, sign, b, "cref ", "cref ");
			callback(op, builtin, sign, b, "cref ", "__");
			callback(op, builtin, sign, b, "__", "cref ");
			callback(op, builtin, sign, b, "__", "__");
		}
		o << '\n';
	};
	o << license;
	o << "/// \\file    " << suffix << ".ny\n";
	o << "/// \\brief   Implementation of the class " << suffix << ", ";
	o << (issigned ? "Signed" : "Unsigned") << " integer with width of exactly " << bits << " bits\n";
	o << "/// \\ingroup std.core\n";
	o << '\n';
	o << "/// \\important THIS FILE IS AUTOMATICALLY GENERATED\n";
	o << '\n';
	o << "/// \\brief   " << (issigned ? "Signed" : "Unsigned");
	o << " integer with width of exactly " << bits << " bits\n";
	o << "/// \\ingroup std.core\n";
	o << "public class " << suffix << " {\n";
	o << "\toperator new;\n\n";
	craftOperator([&](uint32_t b, char targetsign) {
		for ( ; b >= 8; b /= 2) {
			o << "\toperator new (cref x: " << targetsign << b << ") {\n";
			o << "\t\tpod = x.pod;\n";
			o << "\t}\n\n";
		}
	});
	craftOperator([&](uint32_t b, char targetsign) {
		for ( ; b >= 8; b /= 2)
			o << "\t#[nosuggest] operator new (self pod: __" << targetsign << b << ");\n\n";
	});
	addFuncAs(o);
	o << "\toperator ++self: ref " << suffix << " {\n";
	o << "\t\tpod = !!inc(pod);\n";
	o << "\t\treturn self;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator self++: ref " << suffix << " {\n";
	o << "\t\tref tmp = new " << suffix << "(pod);\n";
	o << "\t\tpod = !!inc(pod);\n";
	o << "\t\treturn tmp;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator --self: ref " << suffix << " {\n";
	o << "\t\tpod = !!dec(pod);\n";
	o << "\t\treturn self;\n";
	o << "\t}\n";
	o << '\n';
	o << "\toperator self--: ref " << suffix << " {\n";
	o << "\t\tref tmp = new " << suffix << "(pod);\n";
	o << "\t\tpod = !!dec(pod);\n";
	o << "\t\treturn tmp;\n";
	o << "\t}\n\n";
	auto craftMemberOperator = [&](const AnyString& op, const AnyString& intrinsic, bool prefix) {
		AnyString pr = (prefix and issigned) ? "i" : "";
		craftOperator([&](uint32_t b, char targetsign) {
			for ( ; b >= 8; b /= 2) {
				o << "\toperator " << op << " (cref x: " << targetsign << b << "): ref " << suffix << " {\n";
				o << "\t\tpod = !!" << pr << intrinsic << "(pod, x.pod);\n";
				o << "\t\treturn self;\n";
				o << "\t}\n\n";
				o << "\t#[nosuggest] operator " << op << " (x: __" << targetsign << b << "): ref " << suffix << " {\n";
				o << "\t\tpod = !!" << pr << intrinsic << "(pod, x);\n";
				o << "\t\treturn self;\n";
				o << "\t}\n\n";
			}
		});
	};
	craftMemberOperator("+=", "add", false);
	craftMemberOperator("-=", "sub", false);
	craftMemberOperator("*=", "mul", true);
	craftMemberOperator("/=", "div", true);
	o << "private:\n";
	o << "\tvar pod = 0__" << suffix << ";\n";
	o << '\n';
	o << "} // class " << suffix << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	bool canBeSigned = true;
	auto genGlobalCompareOperator = [&](AnyString op, AnyString builtin, char sign, uint32_t b, AnyString prefixA, AnyString prefixB) {
		o << "#[__nanyc_builtinalias: " << (canBeSigned and issigned ? "i" : "") << builtin;
		if (prefixA.first() == '_' or prefixB.first() == '_')
			o << ", nosuggest";
		o << "] public operator ";
		o << op << " (a: " << prefixA << suffix << ", b: " << prefixB << sign << b << "): ";
		o << ((prefixA.first() == '_' and prefixB.first() == '_') ? "__" : "ref ");
		o << "bool;\n";
	};
	craft(">",  "gt",  genGlobalCompareOperator);
	craft(">=", "gte", genGlobalCompareOperator);
	craft("<",  "lt",  genGlobalCompareOperator);
	craft("<=", "lte", genGlobalCompareOperator);
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	canBeSigned = false;
	craft("==",  "eq",  genGlobalCompareOperator);
	craft("!=",  "neq", genGlobalCompareOperator);
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	auto genGlobalOperator = [&](AnyString op, AnyString builtin, char sign, uint32_t b, AnyString prefixA, AnyString prefixB) {
		bool atLeastOneBuiltin = (prefixA.first() != '_' or prefixB.first() != '_');
		o << "#[__nanyc_builtinalias: " << builtin;
		if (prefixA.first() == '_' or prefixB.first() == '_')
			o << ", nosuggest";
		o << "] public operator ";
		o << op << " (a: " << prefixA << suffix << ", b: " << prefixB << sign << b << "): ";
		o << "any;\n";
		if (not atLeastOneBuiltin)
			o << '\n';
	};
	craft("+", "add", genGlobalOperator);
	craft("-", "sub", genGlobalOperator);
	if (issigned) {
		craft("/", "idiv", genGlobalOperator);
		craft("*", "imul", genGlobalOperator);
	}
	else {
		craft("/", "div", genGlobalOperator);
		craft("*", "mul", genGlobalOperator);
	}
	o << '\n';
	o << '\n';
	o << '\n';
	o << '\n';
	craft("and", "and", genGlobalOperator);
	craft("or", "or", genGlobalOperator);
	craft("xor", "xor", genGlobalOperator);
	craft("mod", issigned ? "modi" : "mod", genGlobalOperator);
	o.trimRight();
	writeFile(filename, o);
}

template<class T, class F> void craftAsAssert(Clob& o, char c, uint32_t bits, F from) {
	constexpr bool f_issigned = std::numeric_limits<F>::is_signed;
	constexpr char f_c = f_issigned ? 'i' : 'u';
	constexpr auto f_bits = sizeof(F) * 8;
	o << "\tassert(std.math.equals(";
	o << std::to_string(static_cast<T>(from)) << c << bits << ", (";
	o << std::to_string(from) << f_c << f_bits << ").as<:" << c << bits << ":>()));\n";
}

template<class T> void craftSingleUnittestsCast(Clob& o) {
	constexpr bool issigned = std::numeric_limits<T>::is_signed;
	constexpr bool isint = std::numeric_limits<T>::is_integer;
	constexpr char c = isint ? (issigned ? 'i' : 'u') : 'f';
	constexpr auto bits = sizeof(T) * 8;
	o<< "unittest std.core.as." << c << bits << " {\n";
	for (int8_t v: {int8_t(0), int8_t(1), int8_t(42), int8_t(-1)}) {
		if (v >= 0) {
			craftAsAssert<T>(o, c, bits, uint8_t(v));
			craftAsAssert<T>(o, c, bits, uint16_t(v));
			craftAsAssert<T>(o, c, bits, uint32_t(v));
			craftAsAssert<T>(o, c, bits, uint64_t(v));
		}
		craftAsAssert<T>(o, c, bits, int8_t(v));
		craftAsAssert<T>(o, c, bits, int16_t(v));
		craftAsAssert<T>(o, c, bits, int32_t(v));
		craftAsAssert<T>(o, c, bits, int64_t(v));
		craftAsAssert<T>(o, c, bits, float(v));
		craftAsAssert<T>(o, c, bits, double(v));
	}
	o << "}\n\n";
}

void craftUnittestsCast(Clob& o, AnyString license, AnyString filename) {
	o = license;
	o << "\n/// \\important THIS FILE IS AUTOMATICALLY GENERATED\n";
	o << '\n';
	craftSingleUnittestsCast<uint8_t>(o);
	craftSingleUnittestsCast<uint16_t>(o);
	craftSingleUnittestsCast<uint32_t>(o);
	craftSingleUnittestsCast<uint64_t>(o);
	craftSingleUnittestsCast<int8_t>(o);
	craftSingleUnittestsCast<int16_t>(o);
	craftSingleUnittestsCast<int32_t>(o);
	craftSingleUnittestsCast<int64_t>(o);
	craftSingleUnittestsCast<float>(o);
	craftSingleUnittestsCast<double>(o);
	o.trimRight();
	writeFile(filename, o);
}

void craftUnittestsModulo(Clob& o, AnyString license, AnyString filename) {
	o = license;
	o << "\n/// \\important THIS FILE IS AUTOMATICALLY GENERATED\n";
	o << '\n';
	auto makeUnittest = [&](auto limit) {
		constexpr bool issigned = std::numeric_limits<decltype(limit)>::is_signed;
		o << "unittest std.core.modulo." << (issigned ? "signed" : "unsigned") << " {\n";
		char c = issigned ? 'i' : 'u';
		for (uint32_t b = 64; b >= 8; b /= 2) {
			for (uint32_t i = 0; i != limit; ++i) {
				for (uint32_t j = 1; j != limit; ++j) {
					o << "\tassert(";
					o << i << c << b;
					o << " mod ";
					o << j << c << b;
					o << " == ";
					o << (decltype(limit)(i) % decltype(limit)(j)) << c << b;
					o << ");\n";
				}
			}
		}
		o << "}\n\n";
	};
	makeUnittest(8);
	makeUnittest(8u);
	o.trimRight();
	writeFile(filename, o);
}

} // namespace

int main(int argc, char** argv) {
	try {
		if (argc != 3)
			throw "usage: <license-header-file> <folder>";
		String license;
		if (IO::errNone != IO::File::LoadFromFile(license, argv[1]))
			throw yuni::String("failed to load header file from '") << argv[1] << '\'';
		std::cout  << "devtool nsl integer/float source file generator\n";
		auto folder = yuni::IO::Canonicalize(argv[2]);
		Clob out;
		out.reserve(1024 * 32);
		String filename;
		filename.reserve(1024);
		for (uint32_t bits = 64; bits >= 8; bits /= 2) {
			filename.clear() << folder << "/std.core/u" << bits << ".ny";
			craftClassInt(out, bits, false, license, filename);
			filename.clear() << folder << "/std.core/i" << bits << ".ny";
			craftClassInt(out, bits, true,  license, filename);
		}
		for (uint32_t bits = 64; bits >= 32; bits /= 2) {
			filename.clear() << folder << "/std.core/f" << bits << ".ny";
			craftClassFloat(out, bits, license, filename);
		}
		filename.clear() << folder << "/nsl.selftest/core/as.ny";
		craftUnittestsCast(out, license, filename);
		filename.clear() << folder << "/nsl.selftest/core/modulo.ny";
		craftUnittestsModulo(out, license, filename);
		return 0;
	}
	catch (const char* e) {
		std::cerr << e << '\n';
	}
	catch (const yuni::String& e) {
		std::cerr << e << '\n';
	}
	catch (const std::bad_alloc&) {
		std::cerr << "error: failed to allocate memory\n";
	}
	catch (const std::exception& e) {
		std::cerr << "exception: " << e.what() << '\n';
	}
	return EXIT_FAILURE;
}
